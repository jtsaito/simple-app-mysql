A Rails App and MySQL in Separate Docker Containers
===================================================

The example simple-app-mysql Rails app contains only a single model
(Note) and a single controller generating a new Note instance and rendering
it as text. Here we describe how to launch the app and the database
(MySQL in our example) in two separate Docker containers and how to
make the database container accessible by linking it from the app container.

A detailed description of how the app container works is given in the
[forerunner example's repo](https://github.com/jtsaito/simple-app).


A. Starting the containers manually
-----------------------------------
This start up only uses the `docker tool`. In Section B we look at using
`docker compose`.


(1) Launch the mysql container.

```
docker run --name some-mysql-2 -e MYSQL_ROOT_PASSWORD=secret_password_here -e MYSQL_DATABASE=simple-app-mysql -d mysql
```

We need to assign the `name` to use it later for the `docker run --link` option when launching the app container.

We are using the `mysql` conatiner from [registry.hub.docker.com](https://registry.hub.docker.com/_/mysql/) which allows passing database name, user name and password by environment variables as in the example call above.

(2) Crucially, we have set the `name` as `host` entry in our `config/databases.yml`.

```
production:
   host: some-mysql-2
```

(3) Build the container.

```
docker build -t jtsaito/simple-app-mysql  .
```

(4) Run the app container's shell.
```
docker run -p 80:80 --link some-mysql-2:some-mysql-2 -i -t --entrypoint /bin/bash jtsaito/simple-app-mysql -s
```

(5) Set up the database for the Rails project on the container.

```
root@e5c1421b3af5:/var/www/simple-app# bundle exec rake db:setup
```

This yields (as expected):

```
simple-app-mysql already exists
-- create_table("notes", {:force=>:cascade})
   -> 0.0371s
-- initialize_schema_migrations_table()
   -> 0.0436s
-- create_table("notes", {:force=>:cascade})
   -> 0.0142s
-- initialize_schema_migrations_table()
   -> 0.0276s
root@e5c1421b3af5:/var/www/simple-app# bundle exec rails c production
Loading production environment (Rails 4.2.0)
irb(main):001:0> Note.all
  Note Load (0.6ms)  SELECT `notes`.* FROM `notes`
=> #<ActiveRecord::Relation []>
```

(6) Launch the container as usual.

```
docker run -p 80:80 --link some-mysql-2:some-mysql-2  -i -t jtsaito/simple-app-mysql -d
```

(7) If we now check with `docker ps` we see both docker containers.

```
CONTAINER ID   IMAGE                             COMMAND CREATED        CREATED             STATUS              PORTS                  NAMES
6d58a615930f   jtsaito/simple-app-mysql:latest   "/bin/sh -c /usr/bin   41 seconds ago      Up 44 seconds       0.0.0.0:80->80/tcp     clever_yonath
5966e75f83d0   mysql:latest                      "/entrypoint.sh mysql  22 minutes ago      Up 22 minutes       3306/tcp some-mysql-2
```

(8) We can now  visit port 80 on our box (when using docker2boot don't forget `boot2docker ip`).


B. Deployment with  docker compose
----------------------------------

Section A described how to manually start the servers. This section
shows how to use `docker-compose` for configuring and linking two
containers. However, first we start up the app container manually
so that we can actuall run the database setup.

(1) Deploy the only the database app by commenting out the app section (`simpleappmysql`) of the docker-compose.yml and running `docker-compose up`

(2) Start the instance manually once for setting up the database. Note

```
docker run -p 80:80 --link simpleappmysql_somemysql2_1:some-mysql-2 -i -rm -t --entrypoint /bin/bash jtsaito/simple-app-mysql -s
```

Note that we link to the mysql cotainer with the name `simpleappmysql_somemysql2_1`. The name follows the automatic convention.

(3) Set up the db on the shell in the simple app container.

```
root@blablabla:/var/www/simple-app# bundle exec rake db:setup
```

(4) Shutdown the container by disconnecting from it.

(5) Comment the section for the app back in.

(6) Run `docker-compose up`.


Now all containers are up and working. `docker ps` yields:

```
CONTAINER ID  IMAGE                                 COMMAND                PORTS               NAMES
d83808c9930d  simpleappmysql_simpleappmysql:latest  "/bin/sh -c /usr/bin   0.0.0.0:80->80/tcp  simpleappmysql_simpleappmysql_1 
c56d782d26ff  mysql:latest                          "/entrypoint.sh mysq   3306/tcp            simpleappmysql_somemysql2_1
```

Note the autogenerated unwieldy names.
